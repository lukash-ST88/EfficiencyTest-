<h2>Тестовое задание на позицию Intern Server Core Programmer </h2>

<h3>Вопрос 1 (task_1) </h3>
Функция my_is_even по сравнению с функцией isEven имеет преимущество в скорости, так как операция логического И в python
реализована быстрее чем операция деления, но уступает ей в читаемости кода. 

<h3>Вопрос 2 (task_2) </h3>
<ui>Задаче task_2 у нас есть два основных типа реализации - через индексы и связанные списки, представленные классами:</ui>
<li>IndexListQueue</li>
<li>linkedListQueue</li>
В примере представлена списки со статическим размером, но обсуждение касается и динамических списков. Так эффективность
работы со списками можно представить следующим образом:
<table>
Таблица 1. Эффективность работы со списками FIFO.
<thead>
<tr>
<th>Класс</th>
<th>Поиск</th>
<th>Вставка</th>
<th>Удаление</th>
</tr> 
<tr>
<th>IndexListQueue</th>
<th>O(1)</th>
<th>O(1)</th>
<th>O(1)</th>
</tr> 
<tr>
<th>LinkedListQueue</th>
<th>O(n)</th>
<th>O(1)</th>
<th>O(1)</th>
</tr> 
</thead>
</table>

Как видно из таблицы 1 эффективность индексируемых и связанных списков практически одинакова. За исключением эффективности поиска, 
из чего можно сделать вывод, что индексируемый список быстрее. Однако, в случае динамического расширения списка, данные списка будут переноситься
на соседнюю ячейку, что замедлят вставку данных при динамическом расширении до O(n). Помимо прочего, данные хранящиеся в коллекции list класса
IndexListQueue занимают больший объем памяти чем данные хранящиеся в переменных класса LinkedlistQueue.


<h3>Вопрос 3 (task_3) </h3>
В примере task_3 представлена реализация наиболее популярных алгоритмов сортировки с их эффективностями. 

Так как размер массива данных изначально не известен, я бы предложил 2 варианта: 
<br>
1) Если массив чисел маленький:
<br>
В таком случае лучше использовать сортировку пузырьком (bubble_sort) или сортировку вставкой (insertion_sort) со средней эффективностью O(n^2).
Потенциально, они быстрее сортировки выбором(selection_sort), и лучше читаются чем алгоритмы быстрой сортировки (quick_sort)
и сортировки слиянием (merge_sort), при этом не прибегают к рекурсии. Обе сортировки имеют высокую максимальную эффективность O(n)
и низкую минимальную O(n^2), при этом их средняя эффективность стремиться к минимальной O(n^2), однко, в случае с маленьким размером данных,
потенциальным проигрышем в эффективности можно пренебречь, в пользу более лаконичной реализации.
Таким образом можно сказать что класс LinkedListQueue лучше подходит для работы и хранения данных, а класс IndexListQueue для чтения данных.

3) Если массив чисел большой:
<br>
В таком случае на первое место выходят параметры скорости и надежности алгоритма. Несмотря, на то что, 
алгоритмы сортировки пузырьком (bubble_sort) и сортировки вставкой (insertion_sort) имеют шанс быть наиболее быстрыми O(n^2),
они также имеют высокую среднюю эффективность, чем сильно повышают риски остаться менее эффективными.
Таким образом лучшим решением будет выбор алгоритма сортировки слиянием(merge_sort) имеющего постоянную эффективность O(n * log(n)).